<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"
			   xmlns:s="library://ns.adobe.com/flex/spark"
			   xmlns:mx="library://ns.adobe.com/flex/mx"
			   minWidth="745" minHeight="410" 
			   backgroundColor="#dcd0c0"
			   creationComplete="testFlashPlayer()"
			   activate="ScriptInterface.signalActivation()" 
			   deactivate="ScriptInterface.signalDeactivation()"
			   pageTitle="Chainsaw">
	
	<fx:Script>
		<![CDATA[
			import chainsaw.events.*;
			import chainsaw.sawdust.*;
			
			import com.adobe.serialization.json.JSON;
			
			import common.DGInterface;
			import common.ScriptInterface;
			import common.VersionChecker;
			
			import flash.external.ExternalInterface;
			import flash.filters.GlowFilter;
			import flash.media.SoundMixer;
			
			import mx.core.UIComponent;
			import mx.logging.ILogger;
			import mx.logging.Log;
			import mx.logging.LogEventLevel;
			import mx.logging.targets.TraceTarget;
			import mx.managers.CursorManager;
			import mx.managers.CursorManagerPriority;
			
			import spark.components.CheckBox;
			import spark.events.TextOperationEvent;
			
			private static const MINIMUM_REQUIREMENTS:Number = 11.4; // the oldest version of flash player you can play this game on.	
			public static const  VERSION:String = "v.1.04";
			private function getVersion():String {
				return( VERSION );
			}
			private static const kCreditsTextHTML:String = 
				"<b>Chainsaw</b> is a <font color='#2C4877'><u><a href='http://www.srri.umass.edu/datagames' target='chainsawInfo'>Data Game</a></u></font> "+
				"created by the <font color='#2C4877'><u><a href='http://www.srri.umass.edu/serg' target='chainsawInfo'>Statistics Education Research Group</a></u></font> "+
				"at <font color='#2C4877'><u><a href='http://www.srri.umass.edu' target='shipInfo'>SRRI</a></u></font>. "+
				"Contributers to the concept, design and development include the "+
				"Research and Activities team: Clifford Konold, Kosoom (Jang) Kreetong; "+
				"Developers: Craig D. Miller, Laurel Shortell; "+
				"Student Programmers: Tristan Warneke, Dylan Pyle, Ryan McCann, Russ Phelan, Mike Salyh. "+
				"Artists: Tristan Warneke, Mike Salyh, Ryan McCann. "+
				"Funded by the National Science Foundation, award "+
				"<font color='#2C4877'><u><a href='http://www.nsf.gov/awardsearch/showAward?AWD_ID=0918653&amp;HistoricalAwards=false' target='chainsawInfo'>DRL-0918653</a></u></font> (2009-2014). "+
				"Chainsaw is open source on <font color='#2C4877'><u><a href='https://github.com/serg-srri-umass/TP-data-games/wiki' target='chainsawInfo'>Github</a></u></font>. "+
				"Copyright (c) 2011<span class='x'>-2014 by University of Massachusetts Amherst.";
			
			public var flashGasTank:MovieClip;

			public var sawdustParticlesLog1:ParticleLauncher = new ParticleLauncher(10, 10, (logY1+95), 0xD4B077);
			public var sawdustParticlesLog2:ParticleLauncher = new ParticleLauncher(10, 10, (logY2+95), 0xD4B077);
			public var sawdustParticlesLog3:ParticleLauncher = new ParticleLauncher(10, 10, (logY3+95), 0xD4B077);
			public var sawdustParticlesLog4:ParticleLauncher = new ParticleLauncher(10, 10, (logY4+95), 0xD4B077);
			
			public var dynamicLog1:MovieClip;
			public var dynamicLog2:MovieClip;
			public var dynamicLog3:MovieClip;
			public var dynamicLog4:MovieClip;
			
			// Embedded Youtube video
			private static const kYouTubeVideoID:String = "51C8VcXNggQ"; // ChainSaw Intro Movie, https://www.youtube.com/watch?v=51C8VcXNggQ on https://www.youtube.com/user/sergsrri
			private static const kYouTubePlayerURL:String = "http://www.youtube.com/apiplayer?version=3";
			private static const kYouTubeAssetsURL1:String = "youtube.com";
			private static const kYouTubeAssetsURL2:String = "s.ytimg.com";
			
			public static const kTimeLimit:Number		= 20;		// Number of seconds player has to cut logs.
			public static const kUpdatesPerSecond:Number= 4;		// Fuel tank updates per second.
			public static const kTotalUpdates:Number	= kTimeLimit * kUpdatesPerSecond; // Total number of updates.
			public static const kUpdateInterval:Number	= 1000 / kUpdatesPerSecond; // Milliseconds between updates.
			public static const kReferenceLength:Number	= 75;		// Reference length in pixels of 16" piece.
			public static const kPercentAllowance:Number= ((1.0/8.0)*100);		// Percent allowed above or below accepted cut length.
			public static const kConvertToInches:Number	= 16.0/kReferenceLength;// Used to convert pixel length to 16".
			public static const kFuelCapacity:Number	= 40;		// Units of fuel when full.
			
			// Levels
			public static const kFreeCutLevel:uint		  = 2;		// Free cut level.
			public static const kHeavyFreeCutLevel:uint   = 3;		// Larger log size free cut level
			public static const kMixedFreeCutLevel:uint   = 4;		// Mixed log size free cut level
			
			// Collection names according to level played.
			public static const kCutsCollectionName:String	= "Cuts";
			public static const kGamesCollectionName:String	= "Games";
			public static const kLevelNameThinLogs:String	= "Thin Logs";
			public static const kLevelNameThickLogs:String	= "Thick Logs";
			public static const kLevelNameMixedLogs:String	= "Mixed Logs";
			public static const kLevelLabelThinLogs:String	= "THIN LOGS LEVEL";
			public static const kLevelLabelThickLogs:String	= "THICK LOGS LEVEL";
			public static const kLevelLabelMixedLogs:String	= "MIXED LOGS LEVEL";
			
			// Strings indicating accptance/rejection status of cut pieces.
			public static const kAcceptString:String		= "Yes";
			public static const kRejectShortString:String	= "No-Short";
			public static const kRejectLongString:String	= "No-Long";
			public static const kRemnantString:String		= "Remnant";
			
			// Min and max accepted cut length in pixels.
			public static const kMinCutLength:Number	= kReferenceLength * (1.0 - (kPercentAllowance / 100));	
			public static const kMaxCutLength:Number	= kReferenceLength * (1.0 + (kPercentAllowance / 100));	
			
			// The y-positions for each log (these are fixed)
			public static const logY1:int = 38;
			public static const logY2:int = 120;
			public static const logY3:int = 202;
			public static const logY4:int = 284
			
			// Create a timer to update the fuel level display and game duration.
			private var mFuelTimer:Timer = new Timer(kUpdateInterval, kTotalUpdates);
			
			private var mFirstGame:Boolean			= true;	// Used for initial operations.
			private var mGameLevel:uint				= 3;	// Current game level. --init as 3 to force it to go through init loops in game select
			private var mPrevLevel:uint				= 3;	// Used to track level changes.
			private var mLogsPerGame:uint			= 4;	// Number of logs being used in each game.
			private var mFuelUsed:Number			= 0;	// Stores how many units of fuel have been used.
			private var mChainsawCursorID:Number	= 0;	// Holds a cursor ID.
			private var mGameNumber:uint			= 0;	// Keeps track of games since app launch. Practice level ignored.
			private var mPiecesAccepted:uint		= 0;	// Number of cut pieces accepted.
			private var mPiecesRejected:uint		= 0;	// Number of cut pieces rejected.
			private var mPiecesShort:uint			= 0;	// Number of cut pieces rejected as short.
			private var mPiecesLong:uint			= 0;	// Number of cut pieces rejected as long.
			private var mPiecesRemnant:uint			= 0;	// Number of cut pieces rejected as remnants.
			private var mPlayersName:String			= "Player"; // Stores player's name.
			private var mStartGameTimer:Timer       = new Timer(1850, 1);
			
			private var currentCutStartPoint:Number; // Holds the starting position for each cut.
			private var mCutStrategy:String = '';	// game strategy at end of game
			private var parentCaseScore:String = ''; // Holds the last value of the Score attribute, if created by the user in the parent case (DG interface only)
			private var practice:Boolean = false; // whether the game is in practice mode or not
			
			// These arrays store the details of individual logs for access by all who need to know.
			private var mLogDetails1:Array;
			private var mLogDetails2:Array;
			private var mLogDetails3:Array;
			private var mLogDetails4:Array;
			
			// Stores array of logs/logtops used in game.
			private var mLogArray:Array;
			
			// Holds piece number beginning at 1 for each cut piece since start of application.
			// Transmitted to TinkerPlots/Fathom. Practice level ignored.
			private var mPieceNumber:uint			= 0;	
			
			// Holds value of piece count as of previous game. Used in free cut levels to calculate
			// piece numbers in cut order rather than location on log.
			private var mPrevPieceNumber:uint		= 0;
			
			// Holds cut number beginning at 1 for cuts made in free cut levels.
			private var mCutNumber:uint				= 0;
			
			// An array that keeps track of the cuts
			private var mCutsArray:Array = new Array();
			
			//conrols playback of dynamic sounds. recieves events from mxml
			private var mSoundHandler:SoundHandler = new SoundHandler();
			
			//coundown movieclip for starting countdown
			private var mCountDownMVC:MovieClip = new CountDownMVC();
			
			// the button on the top-bar that prompts you to watch the instructional video.
			private var mVideoButton:MovieClip = new videoMVC();
			
			//keeps track of whether mouse is down for mouse enabling and disabling purposes. 
			private var mMouseIsDown:Boolean = false;
			
			//The Youtube video player for the intro video
			private var videoPlayer:Object;
			
			//Stores the current volume when sound is muted
			private var volume:Number = 50;
			
			private var logger:ILogger;
			private var mDGInterface:DGInterface = null;	// interface to Data Games container application (if present)
			
			//Used to make sure the tape measure can only be dragged when it is valid
			private var isTapeMeasureDraggable:Boolean = true;
			
			// Embed the cursor symbol.
			// From http://www.rw-designer.com/cursor-download.php?id=2222 on 12/11/2010
			// Converted from .ani format to .png.
			[Embed(source="../embedded_assets/Chainsaw Cursor 2.png")]
			[Bindable] // so we can also use cursor image in the About window
			public var mChainsawCursor:Class;
			
			// Embed the reference length image file.
			[Embed(source="../embedded_assets/Reference Length 75 Pixels.png")]
			[Bindable]
			private var mLengthImage:Class;
			
			// Embed tape measure image
			[Embed(source="../embedded_assets/tape_measure.png")]
			[Bindable]
			private var mTapeMeasureImage:Class;
			
			// Embed video icon
			[Embed(source="../embedded_assets/video_icon.png")]
			[Bindable]
			private var mVideoIcon:Class;
			
			// Embed volume icon
			[Embed(source="../embedded_assets/Volume.png")]
			[Bindable]
			private var mVolumeIcon:Class;
			
			[Embed(source="../embedded_assets/Volume_half.png")]
			[Bindable]
			private var mHalfVolumeIcon:Class;
			
			[Embed(source="../embedded_assets/Volume_low.png")]
			[Bindable]
			private var mLowVolumeIcon:Class;
			
			[Embed(source="../embedded_assets/Volume_off.png")]
			[Bindable]
			private var mMutedVolumeIcon:Class;
			
			// Embed accepted/not accepted/remnant icons
			[Embed(source="../embedded_assets/accepted.png")]
			[Bindable]
			private var mAcceptedImage:Class;
			
			[Embed(source="../embedded_assets/not_accepted.png")]
			[Bindable]
			private var mNotAcceptedImage:Class;
			
			[Embed(source="../embedded_assets/remnant.png")]
			[Bindable]
			private var mRemnantImage:Class;
			
			// The level buttons
			[Embed(source="../embedded_assets/thinlog.png")]
			[Bindable]
			private var mThinLogImage:Class;
			
			[Embed(source="../embedded_assets/thicklog.png")]
			[Bindable]
			private var mThickLogImage:Class;
			
			[Embed(source="../embedded_assets/mixedlog.png")]
			[Bindable]
			private var mMixedLogImage:Class;
			
			
			// test flash player makes sure the player is meeting the minimum requirements.
			private function testFlashPlayer():void
			{
				if( VersionChecker.isValid( MINIMUM_REQUIREMENTS))
				{
					recheckTimer.addEventListener(TimerEvent.TIMER, checkSWFLoaders);
					checkSWFLoaders();
				} else {
					BrickWall.visible = true;
				}
			}
			// startUp() is called when the creation of this class is complete
			// and sets up necessary parameters for game initiation.
			private	function startUp():void
			{
				initLogger();
				
				BrickWall.visible = false;
				
				if(allAssetsLoaded) {

					//preloader code:
					LoadWall.visible = false;
					recheckTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, checkSWFLoaders);
					recheckTimer.stop();
					
					// Arrays store individual cuts on each log for use in free cut levels.		
					mLogDetails1 = new Array(dynamicLog1, null, new Array());
					mLogDetails2 = new Array(dynamicLog2, null, new Array());
					mLogDetails3 = new Array(dynamicLog3, null, new Array());
					mLogDetails4 = new Array(dynamicLog4, null, new Array());
					// Stores array of logs/logtops used in game.
					// Create new log array and add log/logtop to array.
					mLogArray = new Array(mLogDetails1, mLogDetails2, mLogDetails3, mLogDetails4);
					
					// Randomize log array.
					randomizeLogSizePosition();
					
					// add particle emitter to display
					uic.addChild(sawdustParticlesLog1);
					uic.addChild(sawdustParticlesLog2);
					uic.addChild(sawdustParticlesLog3);
					uic.addChild(sawdustParticlesLog4);
					uic.mouseEnabled = false; //not quashing the mouse events from UIC was causing mouse events when its children particles were thrown in front of the mouse
					uic.mouseChildren = false;
					
					levelSelected(kFreeCutLevel); //Start in free cut mode
					
					updateVolume(50); // start with volume at 50% level
					
					// set up DG interface for when ChainSaw.swf is embedded in a DG html doc.
					mDGInterface = new DGInterface( VersionChecker.isDebug );
					this.sendCollectionData();			// send initGame data to TinkerPlots/DG
					// NOTE: callback from DG to restoreStateForDG() could happen here, which calls levelSelected() with new level, etc.
					mDGInterface.createGraphIfNone();	// create a Graph view in DG, if not present already
				} else {
					recheckTimer.reset();
					recheckTimer.start();
					return; 
				}

				// I added a return in the above statement because otherwise, the following code could be run multiple times. -Mike
				
				//add countDown to stage
				uic.addChild(mCountDownMVC);
				mCountDownMVC.x = 745/2;
				mCountDownMVC.y = 410/2;
				
				// init the 'play video' button & prompt.
				initVideoPlayer();
			}
			
			private function initVideoPlayer():void {
				videoBtnContainer.addChild(mVideoButton);
				mVideoButton.x = 600;
				mVideoButton.y = 15;
				
				// all the things that will make the 'click here' prompt go away go here.
				// they need matching 'removeEventListeners' in the closePrompt method.
				
				this.systemManager.stage.addEventListener(MouseEvent.MOUSE_DOWN, closePrompt);
				mVideoButton.videoBtn.addEventListener( MouseEvent.MOUSE_OVER, showHidePrompt);
				mVideoButton.videoBtn.addEventListener( MouseEvent.MOUSE_OUT, showHidePrompt);
				mVideoButton.aboutBtn.addEventListener( MouseEvent.MOUSE_OVER, hideBouncePrompt);
				mVideoButton.aboutBtn.addEventListener( MouseEvent.CLICK, showHideAboutScreen);
				mVideoButton.muteMVC.visible = false;
				
				// this is the method that will be called when the button is clicked on.
				mVideoButton.videoBtn.addEventListener( MouseEvent.CLICK, showVideo);
				
				systemManager.stage.addEventListener(Event.MOUSE_LEAVE, onMouseLeave);
				
				Security.allowDomain( kYouTubeAssetsURL1 ); //Allow flash to load assets from youtube
				Security.allowDomain( kYouTubeAssetsURL2 );
				
				var loader:Loader = new Loader();
				loader.contentLoaderInfo.addEventListener(Event.INIT, onLoaderInit);
				loader.load(new URLRequest(kYouTubePlayerURL));
				//loader.load(new URLRequest("http://www.youtube.com/v/"+kYouTubeVideoID+"?version=3&modestbranding=1&showinfo=1")); //player with controls
				
				function onLoaderInit(event:Event):void {
					videoHolder.addChild(loader);
					loader.content.addEventListener("onReady", onPlayerReady);
					function onPlayerReady(event:Event):void {
						videoPlayer = loader.content;
						videoPlayer.setSize(570, 360);
						videoPlayer.loadVideoById( kYouTubeVideoID);
						videoPlayer.pauseVideo();
						videoPlayer.addEventListener("onStateChange", onVideoStateChange);
					}
				}
			}
			
			// toggles the visibilty of the about screen
			private function showHideAboutScreen( triggerEvent:MouseEvent):void{
				aboutScreen.visible = !aboutScreen.visible;
			}
			
			private function initLogger():void
			{
				var logTarget:TraceTarget = new TraceTarget();
				logTarget.level = LogEventLevel.INFO; //excludes DEBUG messages only
				logTarget.includeLevel = true;
				Log.addTarget(logTarget);
				logger = Log.getLogger("Chainsaw");
			}

			// close the red 'click here' prompt that the video gives you.
			private function closePrompt(e:MouseEvent):void{
				mVideoButton.gotoAndPlay("close");
				mVideoButton.promptMVC.gotoAndStop(1);
				this.systemManager.stage.removeEventListener( MouseEvent.CLICK, closePrompt);
			}
			
			private function showHidePrompt(e:MouseEvent):void{
				if(e.type == MouseEvent.MOUSE_OVER){
					mVideoButton.gotoAndStop(1);
					mVideoButton.promptMVC.gotoAndStop(1);
					mVideoButton.promptMVC.visible = true;
				} else {
					//mVideoButton.gotoAndPlay(1);
					mVideoButton.promptMVC.visible = false;
				}
			}
			
			private function hideBouncePrompt(e:MouseEvent):void{
				mVideoButton.aboutBtn.removeEventListener(MouseEvent.MOUSE_OVER, hideBouncePrompt);
				mVideoButton.gotoAndStop(1);
				mVideoButton.promptMVC.gotoAndStop(1);
				mVideoButton.promptMVC.visible = false;
			}

			// Send the initial game data to DG.  The collections are the tables of cases and attributes.
			private	function	sendCollectionData( ):void	{
				var initGameArgs:Object = {
						name: "Chainsaw",
						dimensions: { width: 745, height: 410 }, // should match 'Application' width and height
						gameEmbedID: 'ChainSaw', // must match the ID of ChainSaw.swf embedded in the DG page by ChainSaw.html
						gameEmbedFunc: 'doCommandFunc', // callback function name to be used by DG/javascript
						collections: [
							{
								name: kGamesCollectionName,
								attrs:[
									{ name: "Player" , type: "nominal" ,  description: "Name of the player"   } ,
									{ name: "GameNumber" , type: "nominal" , precision: 0, description: "Game number"   } , 
									{ name: "Score", type: "numeric", precision: 1, description: "Score for this game", editable: true },
									{ name: "Rank", type: "numeric", precision: 0, description: "Rank of this game", editable: true },
									{ name: "Level" , type: "nominal" ,  description: "Game level"   } ,	
									{ name: "Strategy" , type: "nominal" ,  description: "Cut strategy used by the player"   } ,	
									{ name: "Accepted" , type: "numeric" , precision: 0, description: "Number of pieces accepted"   } , 
									{ name: "Remnant" , type: "numeric" , precision: 0, description: "Number of remnant pieces"   } , 
									//{ name: "Pieces_Rejected" , type: "numeric" , precision: 0, description: "Number of pieces rejected"   } , 
									{ name: "Short" , type: "numeric" , precision: 0, description: "Number of pieces rejected as short"   } , 
									{ name: "Long" , type: "numeric" , precision: 0, description: "Number of pieces rejected as long"   } , 
									{ name: "FuelLeft" , type: "numeric" , precision: 0, description: "Amount of fuel left"   } , 
									{ name: "FuelLeftPercent" , type: "numeric" , precision: 1, description: "Percent of fuel left"   }			
								] ,
								childAttrName: "Cut_Record"
							},
							{
								name: kCutsCollectionName,
								attrs:	[
									{ name: "GameNumber" , type: "nominal" , precision: 0, description: "Game number"   } ,
									{ name: "Length" , type: "numeric" , precision: 2, description: "Length of cut"   } , 
									{ name: "Thickness" , type: "nominal" , description: "Thickness of log"  } , 
									{ name: "IsAccepted" , type: "nominal" , description: "Is piece an acceptable length?",
										colormap: { 
											"Yes": 'green', 	// kAcceptString
											"No-Short": 'red',	// kRejectShortString
											"No-Long": 'red',	// kRejectLongString
											"Remnant": 'yellow'	// kRemnantString
										}},
									{ name: "Log" , type: "numeric" , precision: 0, description: "Log number",
										colormap: { 'attribute-color': '#6f4900'  // brown
										}}
								],
								labels: {
									singleCase: "piece",
									pluralCase: "pieces",
									singleCaseWithArticle: "a piece",
									setOfCases: "cut record",
									setOfCasesWithArticle: "a cut record"
								},
								defaults: { xAttr: "Length", yAttr: "GameNumber", legendAttr: "IsAccepted" }
							}
						] // collections
					}; // initGameArgs
				
				ExternalInterface.addCallback( "doCommandFunc", this.doCommandFromDG ); // make {ChainSaw.swf}.doCommandFromDG() callable from javascript/DG
				this.mDGInterface.initGame( initGameArgs );
			}
			
			// handle a command from DG, such as 'restoreState' or 'saveState'.  
			// 		this.startUp( ) registers this callback function with DG,
			// 		so DG can ask for game state then restore that game state when a DG document is saved then later opened.
			// 		expecting string from DG like: '{ operation: 'restoreState', args: { state: restoredGameState }}'
			public function doCommandFromDG( commandString:String ):String {
				var resultObj:Object = { success: false },
					result:String,
					commandObj:Object = com.adobe.serialization.json.JSON.decode( commandString );
				
				if( commandObj.operation == 'saveState' ) {
					resultObj = this.saveStateforDG( commandObj.args );
				} else if (commandObj.operation == 'restoreState' ) {
					resultObj = this.restoreStateforDG( commandObj.args );
				}		
				if( resultObj )
					result = com.adobe.serialization.json.JSON.encode( resultObj );
				return result;
			}
			
			// handle a 'saveState' command from DG, to stave this game in a document  
			// 		We return information to be passed back to the this game with a restoreStateForDg() call.
			//		Warning: must be compatible with different versions of restoreStateforDG()
			//		Returns { success: true, state: {} }
			private function saveStateforDG( args:Object ):Object {
				var stateObj:Object = 
				{
					success: true,
					state: {
						stateVersion: 1, // increment only if needed by restoreStateForDG()
						playersName: this.mPlayersName,
						gameLevel: this.mGameLevel,
						gameNumber: this.mGameNumber,
						isPractice: this.practice
					}
				};
				return stateObj;
			}
			
			// handle a 'restoreState' command from DG, to restore a game saved in a document.  
			// 		Handles parameters created by a previous save of saveStateForDG()
			//		Warning: must be backward compatible with data created by older versions of saveStateForDG()
			// 		Returns { success: true/false }
			private function restoreStateforDG( args:Object ):Object {
				var iState:Object = args.state,
					result:Object = { success: false };
				if( iState ) {
					if( iState.playersName ) {
						this.mPlayersName = iState.playersName;
						mPlayerTextInput.text = this.mPlayersName; // also update text display
					}
					if( iState.gameNumber ) {
						this.mGameNumber = iState.gameNumber;
					}
					if( iState.isPractice ) {
						this.practice = iState.isPractice;
						this.practiceCheckBox.selected = iState.isPractice;
					}
					switch( iState.gameLevel) {
						case kFreeCutLevel:
						case kHeavyFreeCutLevel:
						case kMixedFreeCutLevel:
							// set level and change level settings
							if( this.mDGInterface.isGameCaseOpen()) {
								trace("restoreStateforDG(): Ignoring restore of DG document's game level; can't do this in the middle of a game");
							} else {
								levelSelected( iState.gameLevel );
							}
							break;
						// else ignore invalid levels
					}
					result.success = true;
				}
				return result;
			}
			
			// clearGame() resets the game according to the current level and clears remnants of
			// the previous game, if any.
			private function clearGame():void
			{
				// hide results overlay if visible from end of previous game
				mResultsOverlay.visible		= false; 
				
				// remove all Status Labels from the holder and hide the holder
				mStatusLabelHolder.visible = false;
				mStatusLabelHolder.removeAllElements();
				
				// Enable/show log cutting edge. Clear all cuts in array.
				for (var i:Number = 0; i < mLogsPerGame; ++i)
				{
					// Clear cut lists on log.
					while (mLogArray[i][2].length > 0)
						mLogArray[i][2].pop();
				}
				
				flashGasTank['resetDrop'](); // Set fuel height back to top of fuel container.
				mFuelUsed = 0;		// Initialize the fuel used to zero.
				
				// Clear sawdust particles
				sawdustParticlesLog1.clearParticles();
				sawdustParticlesLog2.clearParticles();
				sawdustParticlesLog3.clearParticles();
				sawdustParticlesLog4.clearParticles();
			}
			
			// freeCutLevel() sets the current game level to free cut.
			private function thinFreeCutLevel(iEvent:Event):void
			{
				levelScreen.visible = false;
				levelSelected( kFreeCutLevel, true );
			}
			private function thickFreeCutLevel(iEvent:Event):void
			{
				levelScreen.visible = false;
				levelSelected( kHeavyFreeCutLevel, true );
			}
			private function mixedFreeCutLevel(iEvent:Event):void
			{
				levelScreen.visible = false;
				levelSelected( kMixedFreeCutLevel, true );
			}
			
			//level select redirected from button calls with level number - sets up the play field for each level
			private function levelSelected( levelNum:int, logIt:Boolean=false ):void
			{
				practice = practiceCheckBox.selected;
				
				mPrevLevel = mGameLevel; // Track game level change.
				mGameLevel = levelNum; // Set game level
				
				// Only reset if user selects different level (Otherwise it will be reset when they click start)
				if(mPrevLevel != mGameLevel) 
				{
					if(mPrevLevel >= kHeavyFreeCutLevel){
						dynamicLog1.resizeLogFront(35,12);
						dynamicLog1.setLogWidthLabel("thin");
						dynamicLog2.resizeLogFront(35,12);
						dynamicLog2.setLogWidthLabel("thin");
						dynamicLog3.resizeLogFront(35,12);
						dynamicLog3.setLogWidthLabel("thin");
						dynamicLog4.resizeLogFront(35,12);
						dynamicLog4.setLogWidthLabel("thin");
					}
					randomizeLogSizePosition(); // Randomize logs
					
					if(levelNum == kHeavyFreeCutLevel){
						dynamicLog1.resizeLogFront(50,15);
						dynamicLog1.setLogWidthLabel("thick");
						dynamicLog2.resizeLogFront(50,15);
						dynamicLog2.setLogWidthLabel("thick");
						dynamicLog3.resizeLogFront(50,15);
						dynamicLog3.setLogWidthLabel("thick");
						dynamicLog4.resizeLogFront(50,15);
						dynamicLog4.setLogWidthLabel("thick");
						mLevelLabel.text = kLevelLabelThickLogs;
					}else if(levelNum == kMixedFreeCutLevel){
						dynamicLog1.resizeLogFront(50,15);
						dynamicLog1.setLogWidthLabel("thick");
						dynamicLog2.resizeLogFront(35,15);
						dynamicLog2.setLogWidthLabel("thin");
						dynamicLog3.resizeLogFront(50,15);
						dynamicLog3.setLogWidthLabel("thick");
						dynamicLog4.resizeLogFront(35,15);
						dynamicLog4.setLogWidthLabel("thin");
						mLevelLabel.text = kLevelLabelMixedLogs;
					}else{
						mLevelLabel.text = kLevelLabelThinLogs;
					}
					clearGame(); 
					dynamicLog1['init'](0,dynamicLog2); // send cut direction and link to next log
					dynamicLog2['init'](0,dynamicLog3); // cut direction 1=LtoR, -1=RtoL, 0 = free
					dynamicLog3['init'](0,dynamicLog4);
					dynamicLog4['init'](0,null);
					
					// Set the floor of each sawdust emitter when the log thickness changes
					sawdustParticlesLog1['setFloor'](logY1 + dynamicLog1['height'] + 54);
					sawdustParticlesLog2['setFloor'](logY2 + dynamicLog2['height'] + 54);
					sawdustParticlesLog3['setFloor'](logY3 + dynamicLog3['height'] + 54);
					sawdustParticlesLog4['setFloor'](logY4 + dynamicLog4['height'] + 54);
					
					if( logIt ) {
						mDGInterface.sendLog( "newLevel: number="+mGameLevel+" levelName='"+mLevelLabel.text+"', practice="+practice );
					}
				}
				
				mLevelLabel.text = mLevelLabel.text.replace(" (practice)", "");
				if(practice) mLevelLabel.text += " (practice)";
			}
			
			// randomizeLogSizePosition() randomly resorts the logs in the log array.
			protected function randomizeLogSizePosition():void
			{
				dynamicLog1.x = Math.random()*95+5;
				dynamicLog1.y = logY1;
				dynamicLog1['drawNewLog'](pickLogLength());
				
				dynamicLog2.x = Math.random()*95+5;
				dynamicLog2.y = logY2;
				dynamicLog2['drawNewLog'](pickLogLength());
				
				dynamicLog3.x = Math.random()*95+5;
				dynamicLog3.y = logY3;
				dynamicLog3['drawNewLog'](pickLogLength());
				
				dynamicLog4.x = Math.random()*95+5;
				dynamicLog4.y = logY4;
				dynamicLog4['drawNewLog'](pickLogLength());
			}
			
			/**
			 * Helper function for randomizeLogSizePosition() that returns a length as an int that
			 * is long enough for 4 or 5 logs with a little extra padding (1/2 to 6/7 of a log length).
			 * 
			 * @return length
			 * @author Ryan
			 */
			private function pickLogLength():int
			{
				var length:int;
				length = kReferenceLength*4;									// The base length (4 pieces long)
				length+= Math.round(Math.random())*kReferenceLength;			// Randomly add or don't add a 5th piece to the length 
				length+= Math.ceil(Math.random()*(kReferenceLength*0.36)+0.5);	// Finally add 1/2 to 6/7 of a piece to the log as padding
				return length;	// Return the length
			}
			
			// recordPieceStatus() evaluates the piece's acceptance status and records the outcome
			// by setting a visual marker on each log.
			protected function recordPieceStatus(pieceStatus:PieceStatus, pieceNumberBase:uint=0):void
			{
				var currentLog:MovieClip = mLogArray[pieceStatus.mLogNumber-1][0] as MovieClip; // The current log
				
				// Not cutting, so don't specify a cut location.
				if (pieceStatus.mIsEndPiece) pieceStatus.mCutX = 0;
				
				var statusLabel:EnhancedSprite = new EnhancedSprite();
								
				// Accept cut piece if it falls within accepted range.
				var accepted:Boolean = pieceStatus.isAccepted();
				var remnant:Boolean = pieceStatus.isRemnant();
				var acceptString:String = pieceStatus.getAcceptString();
				
				// Keep track of how many cut pieces are accepted / rejected and set status label text.
				if (accepted){
					if (!practice) ++mPieceNumber;
					++mPiecesAccepted;
					statusLabel.loadImage(mAcceptedImage);
				}else if (remnant){
					if (!practice) ++mPieceNumber;
					++mPiecesRemnant;
					statusLabel.loadImage(mRemnantImage);
				}else{
					if (!practice) ++mPieceNumber;
					++mPiecesRejected;
					statusLabel.loadImage(mNotAcceptedImage);
					if(pieceStatus.mLength < kMinCutLength){
						++mPiecesShort;
					}else{
						++mPiecesLong;
					}
				}
				
				// Set y location of the acceptance status label for cut piece.
				statusLabel.y = (currentLog.height / 2) - (statusLabel.getHeight() / 2) + currentLog.y - 2;
				
				// Set x location of the acceptance status label for cut piece.
				if (pieceStatus.mLeftToRight>0){
					// End piece or cutting along same log as at the last cut.
					if (pieceStatus.mIsEndPiece || (!pieceStatus.mIsEndPiece && !pieceStatus.mIsNewLog)){
						statusLabel.x = pieceStatus.mPrevXCut + (pieceStatus.mLength / 2) - (statusLabel.getWidth() / 2) + currentLog.x;
					}
					// Cutting on new log.
					else{
						statusLabel.x = (pieceStatus.mLength / 2) - (statusLabel.getWidth() / 2) + currentLog.x;
					}
				}
				else {
					statusLabel.x = pieceStatus.mCutX + (pieceStatus.mLength / 2) - (statusLabel.getWidth() / 2) + currentLog.x;
				}
				
				//add statusLabel element to holder to be shown later
				mStatusLabelHolder.addElement(statusLabel);
			}
			/*
			Send a single piece data to DG
			*/
			protected function transmitPieceStatus(pieceStatus:PieceStatus, pieceNumberBase:uint=0):void
			{
				var currentLog:MovieClip = mLogArray[pieceStatus.mLogNumber-1][0] as MovieClip; // The current log
				if (!practice)
				{
					var lengthTwoDecimals:String	= (pieceStatus.mLength * kConvertToInches).toFixed(2);
					var pieceNumber:uint 			= pieceStatus.mCutNumber+pieceNumberBase == 0 ? mPieceNumber : pieceStatus.mCutNumber+pieceNumberBase;
					var thickness:String = currentLog.getLogWidthLabel();
					var acceptString:String = pieceStatus.getAcceptString();
					var casesNValues:Array = [[ // array of cases containing array of values
							mGameNumber,
							lengthTwoDecimals,
							thickness,
							acceptString,
							pieceStatus.mLogNumber
						]];
					
					// Send info on cut pieces to DG
					this.mDGInterface.createEventCases( kCutsCollectionName, casesNValues );
				}
			}
			
			// startGame() is called whenever the start button is pressed.
			protected function startGame():void
			{
				//timer to enable mouse activity after coundown movie is done playing
				mStartGameTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onCountdownTimerFinish);
				mStartGameTimer.start();
				
				mCountDownMVC.gotoAndPlay(1); //start countdown movie
				
				mPiecesAccepted		= 0;	// Reset number of cut pieces accepted.
				mPiecesRejected		= 0;	// Reset number of cut pieces rejected.
				mPiecesRemnant		= 0;	// Reset number of remnants
				mPiecesShort		= 0;	// Reset number of rejected short pieces
				mPiecesLong			= 0;	// Reset number of rejected long pieces
				mCutNumber			= 0;	// Reset cut number.
				
				// Randomize log array, but not for first game, as it's already random.
				if (!mFirstGame)
				{
					// Don't randomize if this was just done on level change.
					if (mPrevLevel == mGameLevel)
						randomizeLogSizePosition();
				}
				else mFirstGame = false;
				
				clearGame(); // Clear any remnants of last game and reset game.
				
				mChangeLevelButton.enabled	= false;
				mPlayerTextInput.enabled	= false;
				mChainsawCursorID			= CursorManager.setCursor(mChainsawCursor, CursorManagerPriority.HIGH);
				
				// Use timer to update the fuel level display and game duration.
				if (!practice)
				{
					// Set game number since app launch when new game starts, not counting practice level).
					++mGameNumber;
					// Set up the fuel timer and visual gas tank
					mFuelTimer.addEventListener(TimerEvent.TIMER, timerListener);
					mFuelTimer.reset();	// Reset the timer to run until fuel runs out.
				}			
				
				if (!practice) {				
					// send data to open a case in Game collection to DG
					{
						var gameCaseValues:Array = [
										mPlayersName,
										mGameNumber,
										'', // Score
										'', // Rank
										gameLevelToLevelName( mGameLevel )
									];
						this.mDGInterface.openGameCase( kGamesCollectionName, gameCaseValues );
					}
				}
				//reset SoundHandler completely in case anything has broken during the round
				mSoundHandler.shutDown();
				mSoundHandler = new SoundHandler(); 
				
				//triggering onStart, simulates an onStart event by just directly calling the method 
				mSoundHandler.onStart();
				
				//sending mouseDown, mouseUp, and mouseOutWindow to SoundHandler
				addEventListener(MouseEvent.MOUSE_DOWN, mSoundHandler.onMouseDown);
				addEventListener(MouseEvent.MOUSE_UP, mSoundHandler.onMouseUp);
				addEventListener(MouseEvent.MOUSE_DOWN, mouseIsDown); //for setting boolean
				addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);
				addEventListener(MouseEvent.MOUSE_UP, mouseIsUp); //for setting boolean
				stage.addEventListener(ChainsawEvent.MOUSE_OUT_WINDOW, mSoundHandler.onMouseOutStage);
			}
			
			//when mouse is down, start tracking the position for exiting stage
			private function mouseDownHandler(e:Event):void{
				stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
			}
			
			//when we mouse back up, remove the listener that tracks mouseMoves
			private function mouseUpHandler(e:Event):void{
				stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
			}
			
			//if the mouseMove events show exiting stage, dispatch Chainsaw.MOUSE_OUT_WINDOW
			private function mouseMoveHandler(e:MouseEvent):void{
				if(e.stageX<0 || e.stageX>stage.stageWidth || e.stageY<0 || e.stageY>stage.stageHeight){
					stage.dispatchEvent(new Event(ChainsawEvent.MOUSE_OUT_WINDOW));
					stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
				}
			}
			
			//triggered when countdown animation finishes
			private function onCountdownTimerFinish(e:Event):void{
				if(!mMouseIsDown){
					mSoundHandler.setMouseEnabled(true);
					
					dynamicLog1.enabled = true;
					dynamicLog2.enabled = true;
					dynamicLog3.enabled = true;
					dynamicLog4.enabled = true;
					
					if(!practice)
					{
						mFuelTimer.start(); // Start the timer, now that all variables are set up.
						flashGasTank['initGasTank'](kTimeLimit * 24);
						flashGasTank['startDrop']();
					}
					
					removeEventListener(MouseEvent.MOUSE_UP, onCountdownTimerFinish);
				}
				else{
					addEventListener(MouseEvent.MOUSE_UP, onCountdownTimerFinish);
				}
			}
			
			private  function mouseIsDown(e:MouseEvent):void{
				mMouseIsDown = true;
			}
			
			private function mouseIsUp(e:MouseEvent):void{
				mMouseIsDown = false;
			}
			
			//endGame() performs all operations necessary when game is complete.
			protected function endGame():void
			{
				mSoundHandler.onGameEnd();
				doEndGameStop();
				checkFreeCuts();  // create pieces and send data to DG (via timer)
				mCutStrategy = determineCutStyle();
				
				var fuelLeftFraction:Number	= 1 - (mFuelUsed / kTotalUpdates),
					fuelLeftAmount:Number	= fuelLeftFraction * kFuelCapacity,
					fuelLeftPercent:Number	= fuelLeftFraction * 100;
				
				// Update the results screen
				mAcceptedPiecesValue.text	= mPiecesAccepted.toString();
				mFuelLeftValue.text			= Math.round(fuelLeftAmount).toString();
				mFuelLeftPercent.text		= Math.round(fuelLeftPercent).toString();
//				mCutStyleValue.text			= mCutStrategy;
				mScoreValue.text = "..."; // will be updated again once closeGameCase() is called via timer

				mResultsOverlay.visible		= true;	// Display the results Overlay
				
				mPrevLevel 			= mGameLevel;	// Track game level change.
				mPrevPieceNumber	= mPieceNumber;	// Track piece number at the end of the game.
			}
			
			// sub-function of endGame(), stops all game functions and enables regular UI items
			private function doEndGameStop():void{
				dynamicLog1.enabled = false;//disable all logs from being cut
				dynamicLog2.enabled = false;
				dynamicLog3.enabled = false;
				dynamicLog4.enabled = false;
				
				mStatusLabelHolder.visible=true;//show all status labels
				
				if (!practice)
				{
					mFuelTimer.stop();													// Stop fuel timer.
					mFuelTimer.removeEventListener(TimerEvent.TIMER, timerListener);	// Stop listening.
					flashGasTank['pauseDrop']();	//stop gas tank animation
				}
				
				CursorManager.removeCursor(mChainsawCursorID);	// Remove chainsaw cursor.
/* 				mEngineStopsSound.play();						// Play chainsaw engine stopping sound.
 */				
				mStartStopButton.label			= "Start";
				
				mChangeLevelButton.enabled		= true;
				mPlayerTextInput.enabled		= true;
			}
			
			// Update the game attribute values and close the Game Case, for DG
			// we want to call this at the end of the game, after sending all of the cut data to DG
			private function closeGameCase():void {
				var fuelLeftFraction:Number	= 1 - (mFuelUsed / kTotalUpdates),
					fuelLeftAmount:Number	= fuelLeftFraction * kFuelCapacity,
					fuelLeftPercent:Number	= fuelLeftFraction * 100;
				
				// Send info on games to DG
				if (!practice) {
					// send data to close a case in Game collection to DG
					var	caseID:int = this.mDGInterface.getParentCaseID(),
						caseValues:Array = [
							mPlayersName,
							mGameNumber,
							'', //score
							'', //rank
							gameLevelToLevelName( mGameLevel ),
							mCutStrategy,
							mPiecesAccepted,
							mPiecesRemnant,
							//mPiecesRejected,
							mPiecesShort,
							mPiecesLong,
							fuelLeftAmount,
							fuelLeftPercent
						];
					this.mDGInterface.updateOrCloseGameCase(  kGamesCollectionName, caseValues, true ); // update and close case
					
					// extract value of formula attribute 'score', if created by user in DG
					this.parentCaseScore = "?";  // default for missing, non-numeric, non-string data
					var attributeValues:Array = this.mDGInterface.requestGameAttributeValues( kGamesCollectionName, caseID, ["Score"] );
					if( attributeValues && attributeValues.length >= 1 ) {
						if( attributeValues[0] is Number )
							this.parentCaseScore = attributeValues[0].toFixed(1); // show numeric Score to 1 decimal place
						else if( attributeValues[0] is String && attributeValues[0].length > 0)
							this.parentCaseScore = attributeValues[0]; // show string Score
					}
					mScoreValue.text = this.parentCaseScore;
				}
			}
			
			// sub-fucntion of endGame() to create and check pieces from free cut level
			private function checkFreeCuts():void{
				// Stores individual pieces to be sorted by cut order in a second pass.
				var pieceStatusArray:Array = new Array;
				
				// For each log
				for (var ii:Number = 0; ii < mLogsPerGame; ++ii) 
				{
					// Sort log's cutlist left to right. Must specify NUMERIC or sort will be by string.
					mLogArray[ii][2].sortOn("mCutX", Array.NUMERIC);
					
					var prevCut:Number	= 0;	// Start at the left edge of the log.
					
					// For each cut position
					for (var j:Number = 0; j < mLogArray[ii][2].length; ++j)
					{
						var length:Number		= 0;		// Length of piece.
						var isEnd:Boolean		= false;	// No end pieces in free cut level.
						var leftToRight:Boolean	= true;		// Measuring left to right.
						
						// Piece number for free cut is in cut order, not location on log.
						//	var pieceNumber:uint	= mLogArray[ii][2][j].mCutNumber + pieceNumberBase;
						
						// Calculate the piece length and transmit to TinkerPlots/Fathom.
						length = mLogArray[ii][2][j].mCutX - prevCut;
						
						var pieceStatus:PieceStatus = 
							new PieceStatus(
								length,							// Piece length.
								ii + 1, 						// Number of log (1 is at top).
								isEnd, 							// True if end piece.
								leftToRight,					// True if cutting left to right.
								prevCut == 0,					// True if measuring on new log for first time.
								mLogArray[ii][2][j].mFuelUsed,	// Raw fuel left at the time of piece creation.
								prevCut,						// Cut before this cut or game end.
								mLogArray[ii][2][j].mCutX,		// X cut location on log. 0 if end piece.
								mLogArray[ii][2][j].mCutNumber,	// Cut number.
								mLogArray
							);
						
						pieceStatusArray.push(pieceStatus);
						prevCut = mLogArray[ii][2][j].mCutX;	// Save previous cut position.
						
						// Calculate the rightmost piece length, if it's the final cut.
						if (j == (mLogArray[ii][2].length - 1))
						{
							// Used to increment next cut numbers and provide sequential pieece numbers.
							++pieceNumberBase;
							var lastLength:Number;
							lastLength = mLogArray[ii][0].width - mLogArray[ii][2][j].mCutX - 10; //subtract 10 to account for curve on log face
							var endPieceStatus:PieceStatus = 
								new PieceStatus(
									lastLength,						// Piece length.
									ii + 1, 						// Number of log (1 is at top).
									isEnd, 							// True if end piece.
									leftToRight,					// True if cutting left to right.
									false,							// True if measuring on new log for first time.
									mLogArray[ii][2][j].mFuelUsed,	// Raw fuel left at the time of piece creation.
									prevCut,						// Cut before this cut or game end.
									0,								// X cut location on log. 0 if end piece.
									mLogArray[ii][2][j].mCutNumber,	// Cut number.
									mLogArray
								);
							pieceStatusArray.push(endPieceStatus);
						}
					}
				}
				
				// In second pass, sort pieces by cut number and use these cut numbers to 
				// calculate piece numbers, taking end pieces into account.
				pieceStatusArray.sortOn("mCutNumber", Array.NUMERIC);
				
				// Used in calculating piece numbers.
				var pieceNumberBase:uint	= mPrevPieceNumber;
				var prevCutNumber:uint		= 0;
				
				// For each cut position
				for (var k:Number = 0; k < pieceStatusArray.length; ++k)
				{
					if (pieceStatusArray[k].mCutNumber == prevCutNumber)
						++pieceNumberBase;
					
					// Mark logs with '√', 'X', or 'O'
					recordPieceStatus(pieceStatusArray[k], pieceNumberBase);
					
					prevCutNumber = pieceStatusArray[k].mCutNumber; // Track previous cut number.
				}
				
				/**
				 * Code to send small chunks of data to dg at a time
				 */
				var intID:uint = setInterval(sendChunk, 500); //sends a chunk of data every 500ms
				const chunkSize:int = 10;
				var start:int=0, end:int=chunkSize; //send 10 at a time
				function sendChunk():void
				{
					for (var k:Number = start; k<end && k<pieceStatusArray.length; ++k)
					{
						if (pieceStatusArray[k].mCutNumber == prevCutNumber)
							++pieceNumberBase;
						
						// Transmit to TinkerPlots/Fathom.
						transmitPieceStatus(pieceStatusArray[k], pieceNumberBase);
						
						prevCutNumber = pieceStatusArray[k].mCutNumber; // Track previous cut number.
					} //End for()
					
					start+=chunkSize;
					end+=chunkSize;
					if(end>pieceStatusArray.length) 
						end=pieceStatusArray.length;
					if(start>=end) {
						clearInterval(intID);
						closeGameCase();
					}
				} //End sendChunk()
				
			}
			
			/**
			 * Guesses the cut style of the player using data stored in CutProperties objects,
			 * created after each cut.
			 * @author Ryan
			 */
			private function determineCutStyle():String
			{
				var styleName:String;
				var strategy:int = CutProperties.determineStrategy(mCutsArray);
				switch(strategy)
				{
					case 0:
						styleName = "Single, down";
						break;
					case 1:
						styleName = "Single, downup";
						break;
					case 2:
						styleName = "Multi, down";
						break;
					case 3:
						styleName = "Multi, downup";
						break;
					default:
						styleName = "Other";
				}
				
				//Important - we need to clear out the array each time
				while(mCutsArray.length>0)
				{
					mCutsArray.pop();
				}
				
				return styleName;
			}
			
			// timerListener() is called to update the fuel level display and game duration.
			// now just updates the mFuelUsed
			protected function timerListener(iEvent:TimerEvent):void
			{
				// Increment the units of fuel used at the start, as this amount was used since 
				// the start or previous timer interval.
				++mFuelUsed;
				// If there is still fuel left, provide updates and effects used during game play.
				if (mFuelUsed >= kTotalUpdates){
					// Fuel has been consumed and game is over.
					endGame();					
				}				
			}
			
			// cutLogFreely() performs all cutting operations when the passed in log is cut at 
			// the x position being passed in. The x position is in the coordinate system
			// of the log being cut.
			protected function cutLogFreely(	iLog:MovieClip, 
												iLocalX:Number,
												iTopToBottom:Boolean = true
			):void
			{
				// Don't cut if chainsaw is not running and we're not in practice mode.
				var iLogNumber:int = iLog['getLogNum']();
				if (!practice)
				{
					if (!mFuelTimer.running)
						return;
				}
				
				++mCutNumber;	// Increment cut number.
				
				// Add X position of cut and fuel used to log's cut list.
				var cutAndFuelUsed:FuelUsedAtCut = new FuelUsedAtCut(iLocalX, mFuelUsed, mCutNumber);
				mLogArray[iLogNumber-1][2].push(cutAndFuelUsed);
				
				//store the cut properties
//				var currentLog:MovieClip = mLogArray[iLogNumber-1][0] as MovieClip;
//				var top_bottom:Boolean = currentLog['topToBottomCut']();
				var top_bottom:Boolean = iLog['isTopToBottomCut']();
				var prop:CutProperties = new CutProperties(mCutNumber, iLogNumber, iLocalX, top_bottom);
				mCutsArray.push(prop);
			}
			
			// onChangePlayerTextInput() is called whenever the text is changed in the mPlayerTextInput control.
			protected function onChangePlayerTextInput(/*iEvent:KeyboardEvent*/):void
			{
				mPlayersName = mPlayerTextInput.text;

				//remove focus when user hits enter (purely visual effect)
				//if(iEvent.keyCode == 13) {
				//	mPlayerTextInput.focusManager.hideFocus();
				//}
			}
			
			// Player has pressed the Start/Stop button
			protected function onClickStartStopButton(event:MouseEvent):void{
				if(mStartStopButton.label == "Stop"){
					mStartGameTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, onCountdownTimerFinish); //makes sure timer doesn't still trigger if we've already hit stop 
					mCountDownMVC.gotoAndStop(1); //brings movie back to first frame, and stops
					mSoundHandler.cancelStart(); //cancels the startup sound 
					endGame();
					mStartStopButton.label = "Start";
				}
				else{
					startGame();
					mStartStopButton.label = "Stop";
				}
			}
			
			protected var allAssetsLoaded:Boolean = false;
			protected var recheckTimer:Timer = new Timer(1000, 1);
			
			protected function checkSWFLoaders(e:Event = null):void{
				if(flashGasTank && dynamicLog1 && dynamicLog2 && dynamicLog3 && dynamicLog4){
					allAssetsLoaded = true;
				}
				startUp();
			}
			
			
			//initialize Tristan's gas tank SWF
			protected function initGasTank():void{
				flashGasTank = mFuelIcon.content as MovieClip;
			}
			
			protected function initLog1():void{
				dynamicLog1 = mDynamicLog.content as MovieClip;
				dynamicLog1.enabled = false;
				dynamicLog1.mouseChildren = false;
				dynamicLog1['setLogNum'](1);
				dynamicLog1.addEventListener(MouseEvent.ROLL_OVER, mSoundHandler.onMouseOverLog);
				dynamicLog1.addEventListener(MouseEvent.MOUSE_OUT, mSoundHandler.onMouseOutLog);
			}
			protected function initLog2():void{
				dynamicLog2 = mDynamicLog2.content as MovieClip;
				dynamicLog2.enabled = false;
				dynamicLog2.mouseChildren = false;
				dynamicLog2['setLogNum'](2);
				dynamicLog2.addEventListener(MouseEvent.ROLL_OVER, mSoundHandler.onMouseOverLog);
				dynamicLog2.addEventListener(MouseEvent.MOUSE_OUT, mSoundHandler.onMouseOutLog);
			}
			protected function initLog3():void{
				dynamicLog3 = mDynamicLog3.content as MovieClip;
				dynamicLog3.enabled = false;
				dynamicLog3.mouseChildren = false;
				dynamicLog3['setLogNum'](3);
				dynamicLog3.addEventListener(MouseEvent.ROLL_OVER, mSoundHandler.onMouseOverLog);
				dynamicLog3.addEventListener(MouseEvent.MOUSE_OUT, mSoundHandler.onMouseOutLog);
			}
			protected function initLog4():void{
				dynamicLog4 = mDynamicLog4.content as MovieClip;
				dynamicLog4.enabled = false;
				dynamicLog4.mouseChildren = false;
				dynamicLog4['setLogNum'](4);
				dynamicLog4.addEventListener(MouseEvent.ROLL_OVER, mSoundHandler.onMouseOverLog);
				dynamicLog4.addEventListener(MouseEvent.MOUSE_OUT, mSoundHandler.onMouseOutLog);
			}
			
			//mouse up on currently enabled log, sends to the log's SWF for handling
			protected function logUp(e:MouseEvent):void{
				e.currentTarget.content['logUp'](e);
				sawdustParticlesLog1['stopParticleAnim']();
				sawdustParticlesLog2['stopParticleAnim']();
				sawdustParticlesLog3['stopParticleAnim']();
				sawdustParticlesLog4['stopParticleAnim']();
			}
			//mouse in event on currently enabled log
			protected function logIn(e:MouseEvent):void{
				mSoundHandler.onMouseOverLog(e);
				
				if(e.buttonDown && e.currentTarget.content.enabled){
					var offsetX:Number = e.localX - e.currentTarget.content.x;
					var offsetY:Number = e.localY - e.currentTarget.content.y;
					e.currentTarget.content['logInMod'](offsetX, offsetY);
					
					currentCutStartPoint = e.localX; //save where the cut was started
					
					//prevent showing particles if player is cutting wrong side of log
					if(e.currentTarget.content['canCutAt'](offsetX))
					{
						switch(e.currentTarget)
						{
							case mDynamicLog:
								sawdustParticlesLog1['startParticleAnim']();
								break;
							case mDynamicLog2:
								sawdustParticlesLog2['startParticleAnim']();
								break;
							case mDynamicLog3:
								sawdustParticlesLog3['startParticleAnim']();
								break;
							case mDynamicLog4:
								sawdustParticlesLog4['startParticleAnim']();
								break;
						}
					}
				}
			}
			//mouse out event on enabled log
			protected function logOut(e:MouseEvent):void{
				mSoundHandler.onMouseOutLog(e);
				
				sawdustParticlesLog1['stopParticleAnim']();
				sawdustParticlesLog2['stopParticleAnim']();
				sawdustParticlesLog3['stopParticleAnim']();
				sawdustParticlesLog4['stopParticleAnim']();
				var offsetX:Number = e.localX - e.currentTarget.content.x;
				var offsetY:Number = e.localY - e.currentTarget.content.y;
				if(e.currentTarget.content['logOutMod'](offsetX,offsetY)){
					cutLogFreely(e.currentTarget.content, e.currentTarget.content['StartCutPt'].x);
				}
			}
			//mouse over event for updating cut as they go through the log
			protected function logMidLog(e:MouseEvent):void{				
				if (e.currentTarget.content.enabled){
					var offsetX:Number = e.localX - e.currentTarget.content.x;
					var offsetY:Number = e.localY - e.currentTarget.content.y;
					e.currentTarget.content['midLogMod'](offsetX,offsetY);
				}
				
				if(Math.abs(e.localX - currentCutStartPoint) > 20) logUp(e); //checks to see how far the mouse has moved since beginning to cut
			}
			
			protected function updateVolume(vol:Number):void
			{
				//cannot do: SoundMixer.soundTransform.volume = vol/100;
				var st:SoundTransform = SoundMixer.soundTransform;
				st.volume = vol/100; //changes range [0-100] (slider position) to [0-1] (volume level)
				SoundMixer.soundTransform = st;
				
				//adjust the volume level icon
				if(vol == 0) {
					mVolumeImage.source = mMutedVolumeIcon;
				} else if(vol < 33) {
					mVolumeImage.source = mLowVolumeIcon;
				} else if(vol > 66) {
					mVolumeImage.source = mVolumeIcon;
				} else {
					mVolumeImage.source = mHalfVolumeIcon;
				}
				
				if(videoPlayer != null){
					videoPlayer.setVolume(vol); //Youtube player volume range is [0-100], same as the slider
				}
			}
			
			protected function toggleMute():void
			{
				var muted:Boolean = (SoundMixer.soundTransform.volume == 0);
				if(muted)
				{
					updateVolume(volume);
					mVolumeSlider.value = volume;
				}
				else
				{
					volume = SoundMixer.soundTransform.volume * 100;
					updateVolume(0);
					mVolumeSlider.value = 0;
				}
			}
			
			//Video functions
			private function showVideo(e:Event = null):void
			{
				if(IntroVideo.visible == true)
				{
					if(videoPlayer != null)
						videoPlayer.pauseVideo();
					
					IntroVideo.visible = false;
				}
				else
				{
					IntroVideo.visible = true;
					videoPlayer.playVideo();
				}
			}
			private function hideVideo():void
			{
				videoPlayer.pauseVideo();
				IntroVideo.visible = false;
			}
			private function playPauseVideo():void
			{
				var PLAYING_VIDEO:Number = 1;
				if(videoPlayer.getPlayerState() == PLAYING_VIDEO) {
					videoPlayer.pauseVideo();
				} else {
					videoPlayer.playVideo();
				}
			}
			private function replayVideo():void
			{
				videoPlayer.seekTo(0, true);
				videoPlayer.playVideo();
			}
			private function onVideoStateChange(e:Event):void
			{
				var PLAY:int=1, PAUSE:int=2;
				var state:int = Object(e).data;
				switch(state)
				{
					case PLAY:
						playPauseBtn.label = "Pause"; break;
					case PAUSE:
						playPauseBtn.label = "Play"; break;
				}
			}
			
			private function onMouseDown(e:Event):void
			{
				if(isTapeMeasureDraggable)
				{
					mTapeMeasure.startDrag();
					isTapeMeasureDraggable = false;
					mTapeMeasure.filters = [];
				}
			}
			private function onMouseUp(e:Event):void
			{
				mTapeMeasure.stopDrag();
				
				//animate the tape measure from its current position, back to it's starting position
				//set the animation staring x and y to the cursor x/y minus the tape measure x/y and minus the offset of the UI_Elements container
				moveTapeMeasure.xFrom = mouseX - e.currentTarget.mouseX - UI_Elements.x;
				moveTapeMeasure.yFrom = mouseY - e.currentTarget.mouseY - UI_Elements.y;
				moveTapeMeasure.play();
			}
			private function onTapeMeasureMoveFinish(e:Event):void
			{
				isTapeMeasureDraggable = true; //allow the tape measure to be dragged again once the animation finishes
			}
			private function onMouseOverTapeMeasure(e:Event):void
			{
				mTapeMeasure.filters = [glowFilter];
			}
			private function onMouseOutTapeMeasure(e:Event):void
			{
				mTapeMeasure.filters = [];
			}
			private function onMouseLeave(e:Event):void
			{
				mTapeMeasure.stopDrag();
				
				mTapeMeasure.x = 10;
				
				mTapeMeasure.y = 0;
				mTapeMeasure.y = 5;
				/* This fixes a strange bug where the sprite is not visible after setting its y value.
				It is fixed by setting its value twice to different values.
				*/
				
				isTapeMeasureDraggable = true;
			}
			
			private function onClickCancelLevelsButton(e:Event):void
			{
				levelScreen.visible = false;
				practiceCheckBox.selected = practice;
			}
			
			private function initLevelsScreen(e:Event):void
			{
				thinLevelBtn.addEventListener(MouseEvent.MOUSE_OVER, mouseOverLevelBtn);
				thinLevelBtn.addEventListener(MouseEvent.MOUSE_OUT, mouseOutLevelBtn);
				thickLevelBtn.addEventListener(MouseEvent.MOUSE_OVER, mouseOverLevelBtn);
				thickLevelBtn.addEventListener(MouseEvent.MOUSE_OUT, mouseOutLevelBtn);
				mixedLevelBtn.addEventListener(MouseEvent.MOUSE_OVER, mouseOverLevelBtn);
				mixedLevelBtn.addEventListener(MouseEvent.MOUSE_OUT, mouseOutLevelBtn);
				
				thinLevelBtn.addEventListener(MouseEvent.CLICK, thinFreeCutLevel);
				thickLevelBtn.addEventListener(MouseEvent.CLICK, thickFreeCutLevel);
				mixedLevelBtn.addEventListener(MouseEvent.CLICK, mixedFreeCutLevel);
				
				function mouseOverLevelBtn(e:Event):void
				{
					e.target.filters = [glowFilter];
				}
				function mouseOutLevelBtn(e:Event):void
				{
					e.target.filters = [];
				}
			}
			private function displayLevels(e:Event):void
			{
				initLevelsScreen(e);
				levelScreen.visible = true;
			}
			
			public function gameLevelToLevelName( iGameLevel:uint ):String {
				var levelName:String;					
				switch(mGameLevel) {
					case kFreeCutLevel:
						levelName = kLevelNameThinLogs;
						break;
					case kHeavyFreeCutLevel:
						levelName = kLevelNameThickLogs;
						break;
					case kMixedFreeCutLevel:
						levelName = kLevelNameMixedLogs;
						break;
				}
				return levelName;
			}
		]]>
	</fx:Script>
	
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
		<s:Move id="moveTapeMeasure" target="{mTapeMeasure}" xTo="10" yTo="5" duration="400" effectEnd="onTapeMeasureMoveFinish(event)"/>
		<mx:GlowFilter id="glowFilter" color="0xb81e19" />
	</fx:Declarations>
	
	<s:BorderContainer id="StatusBar" x="5" y="0" width="{this.minWidth - 10}" height="30" cornerRadius="3">
		<s:backgroundFill>
			<s:LinearGradient rotation="90">
				<s:GradientEntry color="0xf0f0f0"/>
				<s:GradientEntry color="0xd8d8d8"/>
			</s:LinearGradient>
		</s:backgroundFill>
		
		<s:Label id="mLevelLabel" x="5" y="3" text="PRACTICE LEVEL" width="318" textAlign="left" height="26" fontSize="14" verticalAlign="middle" fontWeight="bold" fontFamily="Arial" fontStyle="normal" />
		
		<s:Label id="mPlayersNameLabel" x="200" y="8" width="194" fontFamily="Arial" fontSize="14" fontWeight="normal" text="Player's Name" textAlign="right" />
		<s:TextInput id="mPlayerTextInput" x="400" y="2" width="110" height="24" change="onChangePlayerTextInput()" enabled="true"
					 fontSize="14" fontWeight="bold" text="Player" textAlign="left"/>
						
		<s:Image id="mVolumeImage" x="620" y="6" source="{mVolumeIcon}" click="toggleMute()" mouseOver="mVideoButton.muteMVC.visible=true" mouseOut="mVideoButton.muteMVC.visible=false"/>
		<s:HSlider id="mVolumeSlider" x="645" y="9" width="80" change="updateVolume(mVolumeSlider.value)" dataTipPrecision="0" maximum="100" value="50"/>
	</s:BorderContainer>
	
	<s:BorderContainer id="mLogYardContainer" x="135" y="46" width="610" height="364" backgroundAlpha="0" borderVisible="false">
		<s:SWFLoader		id="mDynamicLog" x="-5" y="0" source="chainsaw_assets/DynamicLog.swf" complete="initLog1()" mouseUp="logUp(event)" mouseOver="logIn(event)" mouseOut="logOut(event)" mouseMove="logMidLog(event)" mouseChildren="false"/>
		<s:SWFLoader		id="mDynamicLog2" x="-5" y="0" source="chainsaw_assets/DynamicLog.swf" complete="initLog2()" mouseUp="logUp(event)" mouseOver="logIn(event)" mouseOut="logOut(event)" mouseMove="logMidLog(event)"/>
		<s:SWFLoader		id="mDynamicLog3" x="-5" y="0" source="chainsaw_assets/DynamicLog.swf" complete="initLog3()" mouseUp="logUp(event)" mouseOver="logIn(event)" mouseOut="logOut(event)" mouseMove="logMidLog(event)"/>
		<s:SWFLoader		id="mDynamicLog4" x="-5" y="0" source="chainsaw_assets/DynamicLog.swf" complete="initLog4()" mouseUp="logUp(event)" mouseOver="logIn(event)" mouseOut="logOut(event)" mouseMove="logMidLog(event)"/>
		<s:Group			id="mStatusLabelHolder" x="0" y="0" width="597" height="324" visible="false"/>
	</s:BorderContainer>
	
	<s:BorderContainer id="UI_Elements" x="0" y="36" width="135" height="364" backgroundAlpha="0" borderVisible="false" depth="100">
		<mx:Image id="mTapeMeasure" x="10" y="5" source="{mTapeMeasureImage}" mouseDown="onMouseDown(event)" mouseUp="onMouseUp(event)" depth="100" mouseOver="onMouseOverTapeMeasure(event)" mouseOut="onMouseOutTapeMeasure(event)" buttonMode="true" useHandCursor="true"/>
		<mx:Image id="mReferenceLengthImage" x="13" y="43" source="{mLengthImage}"/>
		<s:Label id="mReferenceLengthLabel" x="10" y="63" fontSize="14" fontWeight="normal" text="Target Length"/>
		<s:Label id="mFuelLabel" x="10" y="100" fontSize="14" fontWeight="normal" text="Fuel"/>
		<s:SWFLoader id="mFuelIcon" x="10" y="120" width="90" height="200" scaleY="1.2" complete="initGasTank()" source="chainsaw_assets/GasTank.swf" />
		<s:Button id="mChangeLevelButton" x="10" y="260" width="90" height="30" label="Levels" click="displayLevels(event)" enabled="true" fontSize="12" fontWeight="bold" />
		<s:Button id="mStartStopButton" x="10" y="300" width="90" height="50" label="Start" mouseDown="onClickStartStopButton(event)" enabled="true" fontSize="14" fontWeight="bold"/>
	</s:BorderContainer>
	
	<mx:UIComponent	id="uic" x="0" y="0"/>
	
	<s:BorderContainer id="mResultsOverlay" x="625" y="46" width="{115}" height="{410-mResultsOverlay.y-30}" cornerRadius="3" backgroundAlpha="1" backgroundColor="#dfdfdf" visible="false">
		<s:backgroundFill>
			<s:LinearGradient rotation="90">
				<s:GradientEntry color="0xf0f0f0"/>
				<s:GradientEntry color="0xd8d8d8"/>
			</s:LinearGradient>
		</s:backgroundFill>
		<s:Label id="mAcceptedPiecesLabel" x="8" y="{60-46}" text="Accepted:" fontSize="14" fontWeight="normal" textAlign="left" color="#0"/>
		<s:Label id="mFuelLeftLabel" x="8" y="{145-46}" text="Fuel:" fontSize="14" fontWeight="normal" textAlign="left" color="#0"/>
		<s:Label id="mCutStyleLabel" x="8" y="{225-46}" text="Fuel %:" fontSize="14" fontWeight="normal" textAlign="left" color="#0"/>
		<s:Label id="mScoreLabel"    x="8" y="{300-46}" text="Score:" fontSize="14" fontWeight="normal" textAlign="left" color="#0"/>
		
		<s:Label id="mAcceptedPiecesValue" x="62" y="{60-46}" text="0" fontSize="14" fontWeight="bold" width="45" textAlign="right" color="#0"/>
		<s:Label id="mFuelLeftValue" x="62" y="{145-46}" text="0" fontSize="14" fontWeight="bold" width="45" textAlign="right" color="#0"/>
		<s:Label id="mFuelLeftPercent" x="62" y="{225-46}" text="Other" fontSize="14" fontWeight="bold" width="45" textAlign="right" color="#0"/>
		<s:Label id="mScoreValue"    x="62" y="{300-46}" text="?" fontSize="14" fontWeight="bold" width="45" textAlign="right" color="#0"/>
	</s:BorderContainer>
	
	<s:Label id="mVersionLabel" x="570" y="386" width="165" fontSize="10" color="#666666" initialize="mVersionLabel.text=getVersion()" textAlign="right" verticalAlign="bottom"/>
	
	<!-- Levels Screen -->
	<s:BorderContainer id="levelScreen" x="{0}" y="{StatusBar.height}" width="{this.minWidth}" height="{this.minHeight-StatusBar.height}" borderVisible="false" backgroundColor="#dcd0c0" visible="false" depth="1000">
		<s:BorderContainer backgroundColor="#e0d4c3" x="{(this.minWidth-460)/2}" y="10" width="460" height="{levelScreen.height-30}" cornerRadius="3">
			<s:filters>
				<s:DropShadowFilter 
					blurX="25" blurY="25" 
					alpha="0.8" />
			</s:filters>
			<!-- 
			<s:backgroundFill>
				<s:LinearGradient rotation="90">
					<s:GradientEntry color="0xf0f0f0"/>
					<s:GradientEntry color="0xd8d8d8"/>
				</s:LinearGradient>
			</s:backgroundFill>
			-->
		</s:BorderContainer>
	
		<s:Image id="thinLevelBtn" x="235" y="40" source="{mThinLogImage}"/>
		<s:Image id="thickLevelBtn" x="235" y="125" source="{mThickLogImage}"/>
		<s:Image id="mixedLevelBtn" x="235" y="220" source="{mMixedLogImage}"/>
			
		<s:CheckBox id="practiceCheckBox" x="220" y="320" label="Practice (no time limit, no data saved)"/>
		
		<s:Button id="closeLevelsButton" x="493" y="310" width="90" height="30" label="Cancel" click="onClickCancelLevelsButton(event)" enabled="true" fontSize="12" fontWeight="bold"/>
	</s:BorderContainer>
	
	<!-- Contains Intro video -->
	<s:BorderContainer id="IntroVideo" x="5" y="0" width="{this.minWidth-10}" height="{this.minHeight}" visible="false" backgroundColor="#dcd0c0" borderVisible="false" depth="1000">
		<mx:UIComponent	id="videoHolder" x="{(this.minWidth-570)/2}" y="10"/>
		<s:Group id="videoControlsContainer" x="{(this.minWidth-this.videoControlsContainer.width)/2}" y="{this.minHeight-this.videoControlsContainer.height-5}">
			<s:Button id="playPauseBtn" label="Pause" click="playPauseVideo()" x="0" />
			<s:Button id="replayBtn" label="Replay" click="replayVideo()" x="{playPauseBtn.width + 5}"/>
			<s:Button id="closeVideoBtn" label="Close" click="hideVideo()" x="{playPauseBtn.width+replayBtn.width+20}" />
		</s:Group>
	</s:BorderContainer>
	
	<mx:UIComponent	id="videoBtnContainer" x="0" y="0"/>
	
	<!-- About Screen -->
	<s:BorderContainer id="aboutScreen" x="{40}" y="{40}" width="{this.minWidth-(2*aboutScreen.x)}" height="{this.minHeight-(2*aboutScreen.y)}" cornerRadius="5" visible="false" depth="1000">
		<s:filters>
			<s:DropShadowFilter 
				blurX="25" blurY="25" 
				alpha="0.8" />
		</s:filters>
		<s:backgroundFill>
			<s:LinearGradient rotation="90">
				<s:GradientEntry color="0xf0f0f0"/>
				<s:GradientEntry color="0xd8d8d8"/>
			</s:LinearGradient>
		</s:backgroundFill>
		<s:Label text="About Chainsaw" width="{aboutScreen.width}" y="35" fontSize="28" fontWeight="normal" textAlign="center"/>
		<mx:Text selectable="true" x="50" y="80" width="{aboutScreen.width-100}" htmlText="{kCreditsTextHTML}" fontSize="14" />
		<s:Button x="{(aboutScreen.width-90)/2}" y="250" width="90" height="30" label="OK" click="aboutScreen.visible=false;" fontSize="12" fontWeight="bold"/>
		<s:Image x="367" y="237" source="{mChainsawCursor}" />
	</s:BorderContainer>
	
	<!-- Loading Screen of Safety -->
	<s:BorderContainer id="LoadWall"	x="0" y="0" width="{this.minWidth}" height="{this.minHeight}" visible="true" >
		<s:backgroundFill>
			<s:LinearGradient rotation="90">
				<s:GradientEntry color="0xEAD1A9"/>
				<s:GradientEntry color="0xBBA178"/>
			</s:LinearGradient>
		</s:backgroundFill>
		<s:Label id="topLabel" text="Loading..." x="0" y="200"  fontSize="20" fontFamily="Arial" fontWeight="bold" textAlign="center" width="745" color="0x000000"/>
	</s:BorderContainer>
	
	<!-- Error message for bad version of flash player -->
	<s:BorderContainer id="BrickWall"	x="0" y="0" width="{this.minWidth}" height="{this.minHeight}" visible="false" >
		<s:backgroundFill>
			<s:LinearGradient rotation="90">
				<s:GradientEntry color="0xFF0000"/>
				<s:GradientEntry color="0xB40404"/>
			</s:LinearGradient>
		</s:backgroundFill>
		<s:Label id="topLabelError" text="You are using an outdated version of Adobe Flash Player." x="0" y="80"  fontSize="20" fontFamily="Arial" fontWeight="bold" textAlign="center" width="745" color="0xffffff"/>
		<s:Label id="midLabelError" text="{'ChainSaw requires Flash Player '+ MINIMUM_REQUIREMENTS +' or later.'}" x="0" y="170"  fontSize="15" fontFamily="Arial" textAlign="center" width="745" color="0xffffff"/>
		<s:Label id="midLabel2Error" text="{'You are currently using Flash Player ' + VersionChecker.getVersion()}" x="0" y="190"  fontSize="15" fontFamily="Arial" textAlign="center" width="745" color="0xffffff"/>
		<s:Button id = "upgradeButton" x="{(745-350)/2}" y="250"  click="VersionChecker.openAdobeWebsite()" label="Upgrade Flash Player" width="350" height="50" fontSize="25" enabled="true"/>
		<s:Button id = "ignoreButton" x="{(745-350)/2}"  y="310"  click="checkSWFLoaders()" label="Ignore Warning" width="350" height="30" fontSize="12" enabled="true"/>
	</s:BorderContainer>

	
</s:Application>
